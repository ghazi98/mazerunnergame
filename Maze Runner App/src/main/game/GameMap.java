package main.game;

import main.game_objects.GameObject;
import main.game_objects.Movable;
import main.game_objects.Player;
import main.game_objects.Position;
import main.maze_generator.MazeGenerator;

import java.util.ArrayList;
import java.util.Collections;

import static main.maze_generator.MazeGenerator.EMPTY_SPACE;

/**
 * A class encapsulating the maze with game objects and the methods to add and remove game objects from the maze.
 *
 * @author Ghazi Suliyanto
 */
public class GameMap {

    private final int height;
    private final int width;
    private char[][] map;
    private ArrayList<Integer> random_X;
    private ArrayList<Integer> random_Y;

    /**
     * @param mazeHeight the number of rows of the maze defined by the player
     * @param mazeWidth  the number of columns of the maze defined by the player
     */
    GameMap(int mazeHeight, int mazeWidth) {
        this.map = new MazeGenerator(mazeHeight, mazeWidth).generate();
        this.height = map.length;
        this.width = map[0].length;
        randomize_X();
        randomize_Y();
    }

    /**
     * Returns a 2D array of characters representing the game map.
     *
     * @return a 2D array of characters representing the game map
     */
    char[][] getMap() {
        return map;
    }

    /**
     * Returns the height of {map}.
     *
     * @return the height of {map}
     */
    public int getHeight() {
        return height;
    }

    /**
     * Returns the width of {map}.
     *
     * @return the width of {map}
     */
    public int getWidth() {
        return width;
    }

    /**
     * Adds the icon character of the specified {GameObject} to the game map at its position.
     *
     * @param object the game object to be added
     */
    void addToMap(GameObject object) {
        map[object.getY()][object.getX()] = object.getIcon();
    }

    /**
     * Removes the icon character of the specified {GameObject} from the game map at its position.
     *
     * @param object the game object to be removed
     */
    void removeFromMap(GameObject object) {
        map[object.getY()][object.getX()] = EMPTY_SPACE;
    }

    /**
     * Generates a list of random x-coordinates that are valid in the map.
     * This method is used to ensure that there's no duplicate coordinates being generated.
     * 
     * The sequence of valid x-coordinates is an arithmetic progression such that:
     * 
     * the first term is 2
     * the difference between the consecutive terms is 4
     * the largest term is less than the {width} of the game map
     * 
     * 
     * Example: 2, 6, 10, 14, 18, ...
     */
    private void randomize_X() {
        this.random_X = new ArrayList<>();
        for (int i = 2; i < this.width; i += 4) this.random_X.add(i);
        Collections.shuffle(this.random_X);
    }

    /**
     * Generates a list of random y-coordinates that are valid in the map.
     * This method is used to ensure that there's no duplicate coordinates being generated.
     * 
     * The sequence of valid y-coordinates is an arithmetic progression such that:
     * 
     * the first term is 1
     * the difference between the consecutive terms is 2
     * the largest term is less than the {height} of the game map
     * 
     * 
     * Example: 1, 3, 5, 7, 9, ....
     */
    private void randomize_Y() {
        this.random_Y = new ArrayList<>();
        for (int i = 1; i < this.height; i += 2) this.random_Y.add(i);
        Collections.shuffle(this.random_Y);
    }

    /**
     * Returns a {Position} object generated by using the random x and y coordinates.
     * The result is passed to the constructor while creating {GameObject} so that we can have our
     * game objects scattered randomly on the game map for each new game.
     *
     * @return a Position object with random x and y coordinates
     */
    Position getRandomPosition() {
        return new Position(random_X.remove(0), random_Y.remove(0));
    }

    /**
     * Returns true if the specified direction the specified Player is trying to move is valid.
     * A valid movement is not blocked by any walls. The validity is determined by checking
     * if the character in the movement's direction is a 'space' that represents 'no wall'.
     *
     * @param player    the Player object
     * @param direction the direction to move
     * @return true if the movement is valid, false otherwise
     */
    boolean validateMovement(Player player, int direction) {
        switch (direction) {
            case Movable.DIRECTION_UP:
                return (player.getY() > 1 && this.map[player.getY() - 1][player.getX()] == EMPTY_SPACE);
            case Movable.DIRECTION_DOWN:
                return (player.getY() < height - 2 && this.map[player.getY() + 1][player.getX()] == EMPTY_SPACE);
            case Movable.DIRECTION_LEFT:
                return (player.getX() > 2 && this.map[player.getY()][player.getX() - 2] == EMPTY_SPACE);
            case Movable.DIRECTION_RIGHT:
                return (player.getX() < width - 3 && this.map[player.getY()][player.getX() + 2] == EMPTY_SPACE);
            default:
                return false;
        }
    }

}
